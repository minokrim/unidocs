"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const globals_json_1 = __importDefault(require("./constants/globals.json"));
const DownloadError_1 = __importDefault(require("./errors/DownloadError"));
const url_1 = require("url");
/**
 * Returns the signature identified by `signatureToken`.
 * @param auth Auth system to generate the correct credentials.
 * @param xhr XHR system to make requests.
 * @param signatureToken token_requester property from a created signature.
 * @returns Signature.
 */
const getSignatureStatus = (auth, xhr, signatureToken) => __awaiter(void 0, void 0, void 0, function* () {
    const token = yield auth.getToken();
    const response = yield xhr.get(`${globals_json_1.default.API_URL_PROTOCOL}://${globals_json_1.default.API_URL}/${globals_json_1.default.API_VERSION}/signature/requesterview/${signatureToken}`, {
        headers: [
            ['Content-Type', 'application/json;charset=UTF-8'],
            ['Authorization', `Bearer ${token}`]
        ],
        transformResponse: res => { return JSON.parse(res); }
    });
    return response;
});
/**
 * Only adds the query param if value is not undefined.
 */
const addOptionalQueryParam = (searchParams, name, value) => {
    if (typeof value !== 'undefined') {
        searchParams.set(name, value);
    }
};
/**
 * Returns a list of the created signatures.
 * A pagination system is used to limit the response length.
 * @param auth Auth system to generate the correct credentials.
 * @param xhr XHR system to make requests.
 * @param page
 * @param pageLimit Limit of objects per page.
 * @param filters.text If specified, searches only signatures that contain this text in the filename, signer's name, or signer's email.
 * @param filters.status If specified, searches only signatures that have this status.
 * @param filters.sort_field What field to sort elements by. "created" sorts by creation date, "filename" sorts by filename alphabetically. Default = "created"
 * @param filters.sort_direction Whether to sort elements in ascending or descending order. Default = "asc"
 * @param filters.created_more_than If specified, searches only signatures created after this date. Format: yyyy-mm-dd
 * @param filters.created_less_than If specified, searches only signatures created before this date. Format: yyyy-mm-dd
 * @returns List of signatures.
 */
const getSignatureList = (auth_1, xhr_1, ...args_1) => __awaiter(void 0, [auth_1, xhr_1, ...args_1], void 0, function* (auth, xhr, page = 0, pageLimit = 20, filters = {}) {
    const token = yield auth.getToken();
    const server = yield getSignServer(xhr, token);
    const searchParams = new url_1.URLSearchParams();
    searchParams.set('page', page.toString());
    searchParams.set('per-page', pageLimit.toString());
    addOptionalQueryParam(searchParams, 'text', filters.text);
    addOptionalQueryParam(searchParams, 'status', filters.status);
    addOptionalQueryParam(searchParams, 'sort_field', filters.sort_field);
    addOptionalQueryParam(searchParams, 'sort_direction', filters.sort_direction);
    addOptionalQueryParam(searchParams, 'created_more_than', filters.created_more_than);
    addOptionalQueryParam(searchParams, 'created_less_than', filters.created_less_than);
    const queryString = searchParams.toString();
    const response = yield xhr.get(`${globals_json_1.default.API_URL_PROTOCOL}://${server}/${globals_json_1.default.API_VERSION}/signature/list?${queryString}`, {
        headers: [
            ['Content-Type', 'application/json;charset=UTF-8'],
            ['Authorization', `Bearer ${token}`]
        ],
        transformResponse: res => { return JSON.parse(res); }
    });
    return response;
});
/**
 * Voids a non-completed signature.
 * @param auth Auth system to generate the correct credentials.
 * @param xhr XHR system to make requests.
 * @param signatureToken token_requester property from a created signature.
 */
const voidSignature = (auth, xhr, signatureToken) => __awaiter(void 0, void 0, void 0, function* () {
    const token = yield auth.getToken();
    const server = yield getSignServer(xhr, token);
    yield xhr.put(`${globals_json_1.default.API_URL_PROTOCOL}://${server}/${globals_json_1.default.API_VERSION}/signature/void/${signatureToken}`, undefined, {
        headers: [
            ['Content-Type', 'application/json;charset=UTF-8'],
            ['Authorization', `Bearer ${token}`]
        ],
    });
});
/**
 * Increases the expiration days limit from a signature.
 * @param auth Auth system to generate the correct credentials.
 * @param xhr XHR system to make requests.
 * @param signatureToken token_requester property from a created signature.
 * @param daysAmount Days to increase.
 */
const increaseSignatureExpirationDays = (auth, xhr, signatureToken, daysAmount) => __awaiter(void 0, void 0, void 0, function* () {
    const token = yield auth.getToken();
    const server = yield getSignServer(xhr, token);
    yield xhr.put(`${globals_json_1.default.API_URL_PROTOCOL}://${server}/${globals_json_1.default.API_VERSION}/signature/increase-expiration-days/${signatureToken}`, JSON.stringify({
        days: daysAmount,
    }), {
        headers: [
            ['Content-Type', 'application/json;charset=UTF-8'],
            ['Authorization', `Bearer ${token}`]
        ],
    });
});
/**
 * Sends reminders to all the receivers to sign, validate or witness a document.
 * @param auth Auth system to generate the correct credentials.
 * @param xhr XHR system to make requests.
 * @param signatureToken token_requester property from a created signature.
 */
const sendReminders = (auth, xhr, signatureToken) => __awaiter(void 0, void 0, void 0, function* () {
    const token = yield auth.getToken();
    const server = yield getSignServer(xhr, token);
    yield xhr.post(`${globals_json_1.default.API_URL_PROTOCOL}://${server}/${globals_json_1.default.API_VERSION}/signature/sendReminder/${signatureToken}`, undefined, {
        headers: [
            ['Content-Type', 'application/json;charset=UTF-8'],
            ['Authorization', `Bearer ${token}`]
        ],
    });
});
/**
 * Returns a PDF or ZIP file with the original files, uploaded
 * at the beginning of the signature creation.
 * @param auth Auth system to generate the correct credentials.
 * @param xhr XHR system to make requests.
 * @param signatureToken token_requester property from a created signature.
 * @returns PDF or ZIP file with the original files.
 */
const downloadOriginalFiles = (auth, xhr, signatureToken) => __awaiter(void 0, void 0, void 0, function* () {
    const token = yield auth.getToken();
    const server = yield getSignServer(xhr, token);
    const data = yield xhr.get(`${globals_json_1.default.API_URL_PROTOCOL}://${server}/${globals_json_1.default.API_VERSION}/signature/${signatureToken}/download-original`, {
        headers: [
            ['Authorization', `Bearer ${token}`]
        ],
        binary: true
    });
    if (!data)
        throw new DownloadError_1.default('File cannot be downloaded');
    return data;
});
/**
 * Returns a PDF or ZIP file with the signed files.
 * @param auth Auth system to generate the correct credentials.
 * @param xhr XHR system to make requests.
 * @param signatureToken token_requester property from a created signature.
 * @returns PDF or ZIP file with the signed files.
 */
const downloadSignedFiles = (auth, xhr, signatureToken) => __awaiter(void 0, void 0, void 0, function* () {
    const token = yield auth.getToken();
    const server = yield getSignServer(xhr, token);
    const data = yield xhr.get(`${globals_json_1.default.API_URL_PROTOCOL}://${server}/${globals_json_1.default.API_VERSION}/signature/${signatureToken}/download-signed`, {
        headers: [
            ['Authorization', `Bearer ${token}`]
        ],
        binary: true
    });
    if (!data)
        throw new DownloadError_1.default('File cannot be downloaded');
    return data;
});
/**
 * Returns a PDF or ZIP file with the audit files that inform about
 * files legitimity.
 * @param auth Auth system to generate the correct credentials.
 * @param xhr XHR system to make requests.
 * @param signatureToken token_requester property from a created signature.
 * @returns PDF or ZIP file with the audit files.
 */
const downloadAuditFiles = (auth, xhr, signatureToken) => __awaiter(void 0, void 0, void 0, function* () {
    const token = yield auth.getToken();
    const server = yield getSignServer(xhr, token);
    const data = yield xhr.get(`${globals_json_1.default.API_URL_PROTOCOL}://${server}/${globals_json_1.default.API_VERSION}/signature/${signatureToken}/download-audit`, {
        headers: [
            ['Authorization', `Bearer ${token}`]
        ],
        binary: true
    });
    if (!data)
        throw new DownloadError_1.default('File cannot be downloaded');
    return data;
});
function getSignServer(xhr, token) {
    return __awaiter(this, void 0, void 0, function* () {
        const { server } = yield xhr.get(`${globals_json_1.default.API_URL_PROTOCOL}://${globals_json_1.default.API_URL}/${globals_json_1.default.API_VERSION}/start/sign`, {
            headers: [
                ['Content-Type', 'application/json;charset=UTF-8'],
                ['Authorization', `Bearer ${token}`]
            ],
            transformResponse: res => { return JSON.parse(res); }
        });
        return server;
    });
}
/**
 * Returns a receiver information related to a specific sign process.
 * @param auth Auth system to generate the correct credentials.
 * @param xhr XHR system to make requests.
 * @param receiverTokenRequester token_requester from a receiver.
 * @returns Receiver information.
 */
const getReceiverInfo = (auth, xhr, receiverTokenRequester) => __awaiter(void 0, void 0, void 0, function* () {
    const token = yield auth.getToken();
    const server = yield getSignServer(xhr, token);
    const data = yield xhr.get(`${globals_json_1.default.API_URL_PROTOCOL}://${server}/${globals_json_1.default.API_VERSION}/signature/receiver/info/${receiverTokenRequester}`, {
        headers: [
            ['Authorization', `Bearer ${token}`]
        ],
        transformResponse: res => { return JSON.parse(res); }
    });
    if (!data)
        throw new DownloadError_1.default('File cannot be downloaded');
    return data;
});
/**
 * Fixes a receiver's email.
 * @param auth Auth system to generate the correct credentials.
 * @param xhr XHR system to make requests.
 * @param receiverTokenRequester token_requester from a receiver.
 * @param email New email.
 */
const fixReceiverEmail = (auth, xhr, receiverTokenRequester, email) => __awaiter(void 0, void 0, void 0, function* () {
    const token = yield auth.getToken();
    const server = yield getSignServer(xhr, token);
    yield xhr.put(`${globals_json_1.default.API_URL_PROTOCOL}://${server}/${globals_json_1.default.API_VERSION}/signature/signer/fix-email/${receiverTokenRequester}`, JSON.stringify({
        email,
    }), {
        headers: [
            ['Content-Type', 'application/json;charset=UTF-8'],
            ['Authorization', `Bearer ${token}`]
        ],
    });
});
/**
 * Fixes a receiver's phone.
 * @param auth Auth system to generate the correct credentials.
 * @param xhr XHR system to make requests.
 * @param receiverTokenRequester token_requester from a receiver.
 * @param phone New phone.
 */
const fixReceiverPhone = (auth, xhr, receiverTokenRequester, phone) => __awaiter(void 0, void 0, void 0, function* () {
    const token = yield auth.getToken();
    const server = yield getSignServer(xhr, token);
    yield xhr.put(`${globals_json_1.default.API_URL_PROTOCOL}://${server}/${globals_json_1.default.API_VERSION}/signature/signer/fix-phone/${receiverTokenRequester}`, JSON.stringify({
        phone,
    }), {
        headers: [
            ['Content-Type', 'application/json;charset=UTF-8'],
            ['Authorization', `Bearer ${token}`]
        ],
    });
});
exports.default = {
    getSignatureStatus,
    getSignatureList,
    voidSignature,
    increaseSignatureExpirationDays,
    sendReminders,
    downloadOriginalFiles,
    downloadSignedFiles,
    downloadAuditFiles,
    getReceiverInfo,
    fixReceiverEmail,
    fixReceiverPhone,
};
//# sourceMappingURL=ILovePDFCoreApi.js.map