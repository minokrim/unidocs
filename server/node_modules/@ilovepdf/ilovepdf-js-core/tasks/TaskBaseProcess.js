"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Task_1 = __importDefault(require("./Task"));
const globals_json_1 = __importDefault(require("../constants/globals.json"));
const ProcessError_1 = __importDefault(require("../errors/ProcessError"));
const typecheck_1 = require("../utils/typecheck");
class TaskBaseProcess extends Task_1.default {
    /**
     * @inheritdoc
     * @param params - Params to run the process step.
     */
    process() {
        return __awaiter(this, arguments, void 0, function* (params = {}) {
            const token = yield this.auth.getToken();
            // Convert to files request format.
            const files = this.getFilesBodyFormat();
            const data = yield this.xhr.post(`${globals_json_1.default.API_URL_PROTOCOL}://${this.server}/${globals_json_1.default.API_VERSION}/process`, JSON.stringify(Object.assign({ task: this.id, tool: this.type, files }, params)), {
                headers: [
                    ['Content-Type', 'application/json;charset=UTF-8'],
                    ['Authorization', `Bearer ${token}`]
                ],
                transformResponse: res => { return JSON.parse(res); }
            });
            const { download_filename, filesize, output_extensions, output_filenumber, output_filesize, status, timer } = data;
            if ((0, typecheck_1.thereIsUndefined)([download_filename, filesize,
                output_extensions, output_filenumber,
                output_filesize, status, timer])) {
                throw new ProcessError_1.default('Task cannot be processed');
            }
            return data;
        });
    }
}
exports.default = TaskBaseProcess;
;
//# sourceMappingURL=TaskBaseProcess.js.map