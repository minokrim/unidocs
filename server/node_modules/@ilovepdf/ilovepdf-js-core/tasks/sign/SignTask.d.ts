import Task from "../Task";
import ILovePDFTool from "../../types/ILovePDFTool";
import { TaskParams } from '../Task';
import Auth from "../../auth/Auth";
import XHRInterface from "../../utils/XHRInterface";
import { GetSignatureStatus } from "../../ILovePDFCoreApi";
import Signer from "./receivers/Signer";
import BaseFile from "../BaseFile";
export interface SignProcessParams {
    /**
     * Emails language that will be received by signers.
     */
    language?: 'en-US' | 'es' | 'fr' | 'it' | 'ca' | 'zh-cn' | 'zh-tw' | 'zh-Hans' | 'zh-Hant' | 'ar' | 'ru' | 'de' | 'ja' | 'pt' | 'bg' | 'ko' | 'nl' | 'el' | 'hi' | 'id' | 'ms' | 'pl' | 'sv' | 'th' | 'tr' | 'uk' | 'vi';
    /**
     * If true, allow signers to sign in parallel. Otherwise, do it sequentially.
     */
    lock_order?: boolean;
    /**
     * Days until the signature request will expire.
     */
    expiration_days?: number;
    /**
     * If true, a signed certified hash and a qualified timestamp is embedded to
     * the signed documents, ensuring document and signatures integrity in the
     * future. Certified signatures are eIDAS, ESIGN & UETA compliant.
     */
    certified?: boolean;
    /**
     * Requester number to facilitate filtering.
     */
    custom_int?: number;
    /**
     * Requester string to facilitate filtering.
     */
    custom_string?: string;
    /**
     * If true, displays UUID at the bottom of the signature. Otherwise, it is hidden.
     * This has only aesthetic purposes.
     */
    uuid_visible?: boolean;
    /**
     * Enables signature reminders.
     */
    reminders?: boolean;
    /**
     * If 'reminders' is true, reminders cycle can be set.
     * 1 <= signer_reminder_days_cycle <= expiration_days.
     */
    signer_reminder_days_cycle?: number;
    /**
     * Brand name that will be displayed in emails.
     * Required if `brand_logo` is set.
     */
    brand_name?: string;
    /**
     * Brand logo that will be displayed in emails.
     * Required if `brand_name` is set.
     */
    brand_logo?: string;
    /**
     * Callback url.
     */
    webhook?: string;
}
export default class SignTask extends Task {
    type: ILovePDFTool;
    private signers;
    constructor(auth: Auth, xhr: XHRInterface, params?: TaskParams);
    process(params?: SignProcessParams): Promise<ProcessReturn>;
    /**
     * Creates a signature object as string to send to server.
     * @param params - Params to create a custom signature.
     */
    private createSignatureData;
    addReceiver(signer: Signer): void;
    addFile(file: string | BaseFile): Promise<BaseFile>;
    private isPdf;
}
type ProcessReturn = GetSignatureStatus;
export {};
