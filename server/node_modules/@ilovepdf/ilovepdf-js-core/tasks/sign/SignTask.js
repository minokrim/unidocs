"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Task_1 = __importDefault(require("../Task"));
const globals_json_1 = __importDefault(require("../../constants/globals.json"));
const SignerAlreadyExistsError_1 = __importDefault(require("../../errors/SignerAlreadyExistsError"));
class SignTask extends Task_1.default {
    constructor(auth, xhr, params = {}) {
        super(auth, xhr, params);
        this.type = 'sign';
        this.signers = [];
    }
    process() {
        return __awaiter(this, arguments, void 0, function* (params = {}) {
            const token = yield this.auth.getToken();
            const body = this.createSignatureData(params);
            const data = yield this.xhr.post(`${globals_json_1.default.API_URL_PROTOCOL}://${this.server}/${globals_json_1.default.API_VERSION}/signature`, body, {
                headers: [
                    ['Content-Type', 'application/json;charset=UTF-8'],
                    ['Authorization', `Bearer ${token}`]
                ],
                transformResponse: res => { return JSON.parse(res); }
            });
            return data;
        });
    }
    /**
     * Creates a signature object as string to send to server.
     * @param params - Params to create a custom signature.
     */
    createSignatureData(params) {
        // Convert to files request format.
        const files = this.getFilesBodyFormat();
        const signers = this.signers.map(signer => (signer.toJSON()));
        return JSON.stringify(Object.assign({ task: this.id, files,
            signers }, params));
    }
    addReceiver(signer) {
        const index = this.signers.indexOf(signer);
        if (index !== -1)
            throw new SignerAlreadyExistsError_1.default();
        // Add signers to manage instance changes.
        this.signers.push(signer);
    }
    addFile(file) {
        const _super = Object.create(null, {
            addFile: { get: () => super.addFile }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const addedFile = yield _super.addFile.call(this, file);
            // Files that are not PDFs don't need to be included inside the
            // array of files.
            // For example: images for the brand logo.
            if (!this.isPdf(addedFile))
                this.files.pop();
            return addedFile;
        });
    }
    isPdf(file) {
        // If the extension is .pdf, is considered a PDF file.
        return /(?:\.pdf)$/i.test(file.filename);
    }
}
exports.default = SignTask;
//# sourceMappingURL=SignTask.js.map