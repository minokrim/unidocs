"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const StartError_1 = __importDefault(require("../errors/StartError"));
const globals_json_1 = __importDefault(require("../constants/globals.json"));
const DeleteError_1 = __importDefault(require("../errors/DeleteError"));
const UpdateError_1 = __importDefault(require("../errors/UpdateError"));
const DownloadError_1 = __importDefault(require("../errors/DownloadError"));
const ConnectError_1 = __importDefault(require("../errors/ConnectError"));
const TaskFactory_1 = __importDefault(require("./TaskFactory"));
const BaseFile_1 = __importDefault(require("./BaseFile"));
const PathError_1 = __importDefault(require("../errors/PathError"));
const typecheck_1 = require("../utils/typecheck");
const ElementAlreadyExistsError_1 = __importDefault(require("../errors/ElementAlreadyExistsError"));
const ElementNotExistError_1 = __importDefault(require("../errors/ElementNotExistError"));
class Task {
    get id() { return this._id; }
    get remainingFiles() { return this._remainingFiles; }
    /**
     *
     * @param publicKey - API public key.
     * @param secretKey - API private key.
     * @param makeStart - If true, start is called on instantiate a Task.
     */
    constructor(auth, xhr, params = {}) {
        this.auth = auth;
        this.xhr = xhr;
        const { id, server, files } = params;
        this._id = !!id ? id : '';
        this.server = !!server ? server : '';
        if (!!files) {
            this.files = files;
        }
        else {
            this.files = [];
        }
    }
    /**
     * @inheritdoc
     */
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            const token = yield this.auth.getToken();
            const data = yield this.xhr.get(`${globals_json_1.default.API_URL_PROTOCOL}://${globals_json_1.default.API_URL}/${globals_json_1.default.API_VERSION}/start/${this.type}`, {
                headers: [
                    ['Content-Type', 'application/json;charset=UTF-8'],
                    ['Authorization', `Bearer ${token}`]
                ],
                transformResponse: res => { return JSON.parse(res); }
            });
            const { task, server, remaining_files } = data;
            if ((0, typecheck_1.thereIsUndefined)([server, task])) {
                throw new StartError_1.default('Task cannot be started');
            }
            this.server = server;
            this._id = this._id ? this._id : task;
            this._remainingFiles = remaining_files;
            return task;
        });
    }
    /**
     * @inheritdoc
     */
    addFile(file_1) {
        return __awaiter(this, arguments, void 0, function* (file, params = { info: false }) {
            if (typeof file === 'string') {
                return this.uploadFromUrl(file, params);
            }
            return this.uploadFromFile(file, params);
        });
    }
    uploadFromUrl(fileUrl, params) {
        return __awaiter(this, void 0, void 0, function* () {
            const token = yield this.auth.getToken();
            const data = yield this.xhr.post(`${globals_json_1.default.API_URL_PROTOCOL}://${this.server}/${globals_json_1.default.API_VERSION}/upload`, JSON.stringify(Object.assign({ task: this.id, cloud_file: fileUrl }, (params.info ? { pdfinfo: params.info } : {}))), {
                headers: [
                    ['Content-Type', 'application/json;charset=UTF-8'],
                    ['Authorization', `Bearer ${token}`]
                ],
                transformResponse: res => { return JSON.parse(res); }
            });
            const { server_filename, pdf_pages, pdf_page_number } = data;
            if ((0, typecheck_1.thereIsUndefined)([server_filename]))
                throw new UpdateError_1.default('File cannot be uploaded');
            const file = new BaseFile_1.default(this.id, server_filename, this.getBasename(fileUrl));
            if (params.info) {
                file.info = {
                    pageSizes: pdf_pages.map(size => size
                        .split('x')
                        .flatMap(coord => parseInt(coord))),
                    pageNumber: pdf_page_number,
                };
            }
            this.files.push(file);
            return file;
        });
    }
    getBasename(path) {
        const firstIndex = path.lastIndexOf('/') + 1;
        if (firstIndex === -1)
            throw new PathError_1.default('Path is malformed');
        const basename = path.substring(firstIndex);
        return basename;
    }
    uploadFromFile(file, params) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.files.indexOf(file) !== -1) {
                throw new ElementAlreadyExistsError_1.default();
            }
            const token = yield this.auth.getToken();
            // Populate file with control data.
            file.taskId = this.id;
            if (params.info) {
                file.info = { pageNumber: 0, pageSizes: [] };
            }
            const data = yield this.xhr.post(`${globals_json_1.default.API_URL_PROTOCOL}://${this.server}/${globals_json_1.default.API_VERSION}/upload`, file, {
                headers: [
                    ['Authorization', `Bearer ${token}`]
                ],
                transformResponse: res => { return JSON.parse(res); }
            });
            const { server_filename, pdf_pages, pdf_page_number } = data;
            if ((0, typecheck_1.thereIsUndefined)([server_filename]))
                throw new UpdateError_1.default('File cannot be uploaded');
            // Populate file with control data.
            file.serverFilename = server_filename;
            // Populate info if required.
            if (params.info) {
                file.info = {
                    pageSizes: pdf_pages.map(size => size
                        .split('x')
                        .flatMap(coord => parseInt(coord))),
                    pageNumber: pdf_page_number,
                };
            }
            // Insert inside the array of included files.
            this.files.push(file);
            return file;
        });
    }
    /**
     * @inheritdoc
     */
    deleteFile(file) {
        return __awaiter(this, void 0, void 0, function* () {
            const token = yield this.auth.getToken();
            const index = this.files.indexOf(file);
            if (index === -1)
                throw new ElementNotExistError_1.default();
            const fileToRemove = this.files[index];
            yield this.xhr.delete(`${globals_json_1.default.API_URL_PROTOCOL}://${this.server}/${globals_json_1.default.API_VERSION}/upload/${this.id}/${fileToRemove.serverFilename}`, {
                headers: [
                    ['Content-Type', 'application/json;charset=UTF-8'],
                    ['Authorization', `Bearer ${token}`]
                ],
                transformResponse: res => { return JSON.parse(res); }
            });
            // Remove file locally.
            this.files.splice(index, 1);
        });
    }
    getFilesBodyFormat() {
        const files = this.files.map((file) => {
            return {
                server_filename: file.serverFilename,
                filename: file.filename,
                rotate: file.params.rotate,
                password: file.params.password
            };
        });
        return files;
    }
    /**
     * @inheritdoc
     */
    download() {
        return __awaiter(this, void 0, void 0, function* () {
            const token = yield this.auth.getToken();
            const data = yield this.xhr.get(`${globals_json_1.default.API_URL_PROTOCOL}://${this.server}/${globals_json_1.default.API_VERSION}/download/${this.id}`, {
                headers: [
                    ['Authorization', `Bearer ${token}`]
                ],
                binary: true
            });
            // Be careful with this negation. It depends on server response:
            // Error if data === undefined || data === '' || data === null || data === false.
            if (!data)
                throw new DownloadError_1.default('File cannot be downloaded');
            return data;
        });
    }
    /**
     * @inheritdoc
     */
    delete() {
        return __awaiter(this, void 0, void 0, function* () {
            const token = yield this.auth.getToken();
            const data = yield this.xhr.delete(`${globals_json_1.default.API_URL_PROTOCOL}://${this.server}/${globals_json_1.default.API_VERSION}/task/${this.id}`, {
                headers: [
                    ['Content-Type', 'application/json;charset=UTF-8'],
                    ['Authorization', `Bearer ${token}`]
                ],
                transformResponse: res => { return JSON.parse(res); }
            });
            const { download_filename, file_number, filesize, output_extensions, output_filesize, output_filenumber, process_start, server, status, status_message, task, timer, tool } = data;
            if ((0, typecheck_1.thereIsUndefined)([download_filename, filesize,
                output_extensions, output_filenumber, output_filesize,
                status, timer, file_number, process_start, server,
                status_message, task, tool])) {
                throw new DeleteError_1.default('Task cannot be deleted');
            }
        });
    }
    /**
     * @inheritdoc
     */
    connect(nextTool) {
        return __awaiter(this, void 0, void 0, function* () {
            const token = yield this.auth.getToken();
            const data = yield this.xhr.post(`${globals_json_1.default.API_URL_PROTOCOL}://${this.server}/${globals_json_1.default.API_VERSION}/task/next`, JSON.stringify({
                task: this.id,
                tool: nextTool
            }), {
                headers: [
                    ['Content-Type', 'application/json;charset=UTF-8'],
                    ['Authorization', `Bearer ${token}`]
                ],
                transformResponse: res => { return JSON.parse(res); }
            });
            const { task, files } = data;
            if ((0, typecheck_1.thereIsUndefined)([task, files])) {
                throw new ConnectError_1.default('Task cannot be connected');
            }
            const newTaskFiles = Object.entries(files).map(([server_filename, filename]) => {
                return new BaseFile_1.default(this.id, server_filename, filename);
            });
            const taskFactory = new TaskFactory_1.default();
            // Create the next new task and populate its attrs with response data.
            // The server is the same than parent task.
            const newTask = taskFactory.newTask(nextTool, this.auth, this.xhr, { id: task, server: this.server, files: newTaskFiles });
            return newTask;
        });
    }
}
exports.default = Task;
//# sourceMappingURL=Task.js.map