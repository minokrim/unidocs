"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = __importDefault(require("axios"));
const HTTPVerbNotSupportedError_1 = __importDefault(require("../errors/HTTPVerbNotSupportedError"));
class XHRPromise {
    get(url, options = {}) {
        return XHRPromise.makeRequest('GET', url, undefined, options);
    }
    post(url, data, options = {}) {
        // If it is a file, it has special treatment with HTTP extracting its data.
        if (typeof data !== 'string' && typeof data !== 'undefined') {
            const [injectedData, injectedOptions] = this.injectRequestInformation(data, options);
            return XHRPromise.makeRequest('POST', url, injectedData, injectedOptions);
        }
        return XHRPromise.makeRequest('POST', url, data, options);
    }
    // ILovePDFFiles has to be sent with a specific HTTP configuration.
    injectRequestInformation(data, options) {
        // Access to "native" data.
        const formData = data.data;
        const injectedData = formData.getBuffer();
        const extraHeaders = formData.getHeaders();
        // 'form-data' package returns Content-Type as content-type. This is an
        // error due to the first words have to be in upper-case. We fix this here.
        extraHeaders['Content-Type'] = extraHeaders['content-type'];
        delete extraHeaders['content-type'];
        // Inject new headers with old headers.
        let headersArray = !!options.headers ? options.headers : [];
        const headersConcat = Object.entries(extraHeaders).concat(headersArray);
        // Copy object.
        const injectedOptions = Object.assign({}, options);
        // Set binary option.
        injectedOptions.headers = headersConcat;
        return [injectedData, injectedOptions];
    }
    put(url, data, options = {}) {
        return XHRPromise.makeRequest('PUT', url, data, options);
    }
    delete(url, options = {}) {
        return XHRPromise.makeRequest('DELETE', url, undefined, options);
    }
    static makeRequest(method, url, data, options = {}) {
        const requestConfig = XHRPromise.getRequestConfig(options);
        switch (method) {
            case 'GET':
                return XHRPromise.getRequest(url, requestConfig);
            case 'POST':
                return XHRPromise.postRequest(url, requestConfig, data);
            case 'PUT':
                return XHRPromise.putRequest(url, requestConfig, data);
            case 'DELETE':
                return XHRPromise.deleteRequest(url, requestConfig);
            default:
                throw new HTTPVerbNotSupportedError_1.default();
        }
    }
    static getRequest(url, config) {
        return axios_1.default.get(url, config)
            .then(response => {
            return response.data;
        });
    }
    static deleteRequest(url, config) {
        return axios_1.default.delete(url, config)
            .then(response => {
            return response.data;
        });
    }
    static postRequest(url, config, data) {
        return axios_1.default.post(url, data, config)
            .then(response => {
            return response.data;
        });
    }
    static putRequest(url, config, data) {
        return axios_1.default.put(url, data, config)
            .then(response => {
            return response.data;
        });
    }
    static getRequestConfig(options) {
        const headers = {};
        if (!!options.headers) {
            options.headers.forEach(([key, value]) => {
                headers[key] = value;
            });
        }
        // Configuration to not encode in case of binary file.
        const responseType = !!options.binary ? 'arraybuffer' : 'text';
        // Transform response.
        const { transformResponse } = options;
        return {
            headers,
            responseType,
            transformResponse,
            maxBodyLength: Infinity,
            maxContentLength: Infinity,
        };
    }
}
exports.default = XHRPromise;
//# sourceMappingURL=XHRPromise.js.map