import ILovePDFTool from "@ilovepdf/ilovepdf-js-core/types/ILovePDFTool";
import TaskI from "@ilovepdf/ilovepdf-js-core/tasks/TaskI";
import { GetSignatureStatus, GetReceiverInfoResponse, SignatureListFilters } from '@ilovepdf/ilovepdf-js-core/ILovePDFCoreApi';
export interface ILovePDFApiI {
    /**
     * Creates a new task for a specific tool.
     * @param taskType - Task to run.
     */
    newTask: (taskType: ILovePDFTool) => TaskI;
    /**
     * Returns a task lists from ILovePDF servers ordered from newest to older.
     */
    listTasks: (params?: ListTasksParams) => Promise<Array<TaskI>>;
    /**
     * Returns the signature identified by `signatureToken`.
     * @param signatureToken token_requester property from a created signature.
     * @returns Signature.
     */
    getSignatureStatus: (signatureToken: string) => Promise<GetSignatureStatus>;
    /**
     * Returns a list of the created signatures.
     * A pagination system is used to limit the response length.
     * @param page
     * @param pageLimit Limit of objects per page.
     * @returns List of signatures.
     */
    getSignatureList: (page: number, pageLimit: number) => Promise<Array<GetSignatureStatus>>;
    /**
     * Voids a non-completed signature.
     * @param signatureToken token_requester property from a created signature.
     */
    voidSignature: (signatureToken: string) => Promise<void>;
    /**
     * Increases the expiration days limit from a signature.
     * @param signatureToken token_requester property from a created signature.
     * @param daysAmount Days to increase.
     */
    increaseSignatureExpirationDays: (signatureToken: string, daysAmount: number) => Promise<void>;
    /**
     * Sends reminders to all the receivers to sign, validate or witness a document.
     * @param signatureToken token_requester property from a created signature.
     */
    sendReminders: (signatureToken: string) => Promise<void>;
    /**
     * Returns a PDF or ZIP file with the original files, uploaded
     * at the beginning of the signature creation.
     * @param signatureToken token_requester property from a created signature.
     * @returns PDF or ZIP file with the original files.
     */
    downloadOriginalFiles: (signatureToken: string) => Promise<Uint8Array>;
    /**
     * Returns a PDF or ZIP file with the signed files.
     * @param signatureToken token_requester property from a created signature.
     * @returns PDF or ZIP file with the signed files.
     */
    downloadSignedFiles: (signatureToken: string) => Promise<Uint8Array>;
    /**
     * Returns a PDF or ZIP file with the audit files that inform about
     * files legitimity.
     * @param signatureToken token_requester property from a created signature.
     * @returns PDF or ZIP file with the audit files.
     */
    downloadAuditFiles: (signatureToken: string) => Promise<Uint8Array>;
    /**
     * Returns a receiver information related to a specific sign process.
     * @param receiverTokenRequester token_requester from a receiver.
     * @returns Receiver information.
     */
    getReceiverInfo: (receiverTokenRequester: string) => Promise<GetReceiverInfoResponse>;
    /**
     * Fixes a receiver's email.
     * @param receiverTokenRequester token_requester from a receiver.
     * @param email New email.
     */
    fixReceiverEmail: (receiverTokenRequester: string, email: string) => Promise<void>;
    /**
     * Fixes a receiver's phone.
     * @param receiverTokenRequester token_requester from a receiver.
     * @param phone New phone.
     */
    fixReceiverPhone: (receiverTokenRequester: string, phone: string) => Promise<void>;
}
export type ILovePDFApiParams = {
    file_encryption_key?: string;
};
export default class ILovePDFApi implements ILovePDFApiI {
    private auth;
    private xhr;
    private taskFactory;
    constructor(publicKey: string, secretKey: string, params?: ILovePDFApiParams);
    /**
     * @inheritdoc
     */
    newTask(taskType: ILovePDFTool): TaskI;
    /**
     * @inheritdoc
     */
    listTasks(params?: ListTasksParams): Promise<TaskI[]>;
    /**
     * @inheritdoc
     */
    getSignatureStatus(signatureToken: string): Promise<GetSignatureStatus>;
    /**
     * @inheritdoc
     */
    getSignatureList(page?: number, pageLimit?: number, filters?: SignatureListFilters): Promise<Array<GetSignatureStatus>>;
    /**
     * @inheritdoc
     */
    voidSignature(signatureToken: string): Promise<void>;
    /**
     * @inheritdoc
     */
    increaseSignatureExpirationDays(signatureToken: string, daysAmount: number): Promise<void>;
    /**
     * @inheritdoc
     */
    sendReminders(signatureToken: string): Promise<void>;
    /**
     * @inheritdoc
     */
    downloadOriginalFiles(signatureToken: string): Promise<Uint8Array>;
    /**
     * @inheritdoc
     */
    downloadSignedFiles(signatureToken: string): Promise<Uint8Array>;
    /**
     * @inheritdoc
     */
    downloadAuditFiles(signatureToken: string): Promise<Uint8Array>;
    /**
     * @inheritdoc
     */
    getReceiverInfo(receiverTokenRequester: string): Promise<GetReceiverInfoResponse>;
    /**
     * @inheritdoc
     */
    fixReceiverEmail(receiverTokenRequester: string, email: string): Promise<void>;
    /**
     * @inheritdoc
     */
    fixReceiverPhone(receiverTokenRequester: string, phone: string): Promise<void>;
}
type ListTasksParams = {
    page?: number;
    tool?: string;
    status?: string;
    custom_int?: number;
};
export {};
